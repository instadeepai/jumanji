# Copyright 2022 InstaDeep Ltd. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import abc
import collections
import csv
import functools
import math
import operator
from typing import List, Optional, Tuple, cast

import chex
import jax
import jax.numpy as jnp

from jumanji.environments.packing.bin_pack.space import Space
from jumanji.environments.packing.bin_pack.types import (
    Container,
    Item,
    Location,
    State,
    ValuedItem,
    empty_ems,
    item_from_space,
    location_from_space,
    rotated_items_from_space,
    space_from_item_and_location,
    valued_item_from_space_and_max_value,
)
from jumanji.tree_utils import tree_slice, tree_transpose

# 20 foot container: 5.898m long x 2.352m wide x 2.393m high
# Oftentimes people use different values (inner volume) : 5.870m long x 2.330m wide x 2.200m high
# real_container_volume = 1.103 * inner_container_volume
TWENTY_FOOT_DIMS = (5870, 2330, 2200)

CSV_COLUMNS = ["Item_Name", "Length", "Width", "Height", "Quantity"]
CSV_VALUE_PROBLEM_COLUMNS = [
    "Item_Name",
    "Length",
    "Width",
    "Height",
    "Quantity",
    "Value",
]


def make_container(container_dims: Tuple[int, int, int]) -> Container:
    """Return a non-normalized `Container` whose dimensions are in millimeters.

    Args:
        container_dims: (length, width, height) tuple of integers corresponding to the dimensions
            of the container in millimeters.

    Returns:
        unnormalized container whose bottom-left corner is (0, 0, 0) and top-right corner is
            defined by container_dims.

    """
    x2, y2, z2 = container_dims
    container = Container(x1=0, x2=x2, y1=0, y2=y2, z1=0, z2=z2).astype(jnp.int32)
    return container


class Generator(abc.ABC):
    """Defines the abstract `Generator` base class. A `Generator` is responsible
    for generating an instance when the environment is reset.
    """

    def __init__(
        self, max_num_items: int, max_num_ems: int, container_dims: Tuple[int, int, int]
    ):
        """Abstract class implementing `max_num_items` and `max_num_ems` properties.

        Args:
            max_num_items: maximum number of items the generator will ever generate when creating
                a new instance. This defines the shapes of arrays related to items in the
                environment state.
            max_num_ems: maximum number of ems the environment will handle. This defines the shape
                of the EMS buffer that is kept in the environment state.
            container_dims: dimensions of the container generated by the instance generator.
        """
        self._max_num_items = max_num_items
        self._max_num_ems = max_num_ems
        self._container_dims = container_dims

    @property
    def max_num_items(self) -> int:
        """Returns the maximum number of items the generator will ever create when resetting the
        environment.
        """
        return self._max_num_items

    @property
    def max_num_ems(self) -> int:
        """Returns the maximum number of ems the environment will handle. Any created ems that do
        not fit in the buffer will be ignored during the environment step.
        """
        return self._max_num_ems

    @property
    def container_dims(self) -> Tuple[int, int, int]:
        """Returns the dimensions of the container generated by the instance generator."""
        return self._container_dims

    @abc.abstractmethod
    def __call__(self, key: chex.PRNGKey) -> State:
        """Call method responsible for generating a new state.

        Args:
            key: jax random key for any stochasticity used in the instance generation process.

        Returns:
            A `BinPack` state.
        """

    def generate_solution(self, key: chex.PRNGKey) -> State:
        """Returns a state in which all items are placed to show a solution to the packing problem.
        The state corresponds to the end of an episode run with the optimal policy.

        Args:
            key: same jax random key used than when calling `__call__` to generate the same
                instance.

        Returns:
            A `BinPack` state whose items are all placed.
        """
        raise NotImplementedError

    def _unpack_items(self, state: State) -> State:
        """Unpack any items that were packed in the given state. Reset to how the state was at the
        beginning of the episode.
        """
        state.ems_mask = jnp.zeros(self.max_num_ems, bool).at[0].set(True)
        state.items_placed = jnp.zeros(self.max_num_items, bool)
        state.items_location = Location(
            *tuple(jnp.zeros((3, self.max_num_items), jnp.int32))
        )
        return state


class ToyGenerator(Generator):
    """`Generator` that can be used as an example. It deterministically outputs a single
    instance with 20 items that can be packed in a way to fully utilize a 20-ft container.
    """

    def __init__(self) -> None:
        """Instantiate a `ToyGenerator` with 20 items and 60 EMSs maximum."""
        super().__init__(
            max_num_items=20, max_num_ems=60, container_dims=TWENTY_FOOT_DIMS
        )

    def __call__(self, key: chex.PRNGKey) -> State:
        """Call method responsible for generating a new state. It returns a 20-ft container instance
        without any placed items.

        Args:
            key: jax random key for any stochasticity used in the generation process

        Returns:
            A `BinPack` state.
        """
        solution = self._generate_solved_instance(key)
        state = self._unpack_items(solution)

        return state

    def generate_solution(self, key: chex.PRNGKey) -> State:
        """Returns a state in which all items are placed to show a solution to the packing problem.
        The state corresponds to the end of an episode that was run with the optimal policy.

        Args:
            key: same jax random key used than when calling `__call__` to generate the same
                instance.

        Returns:
            A `BinPack` state whose items are all placed.

        Example:
            ```python
            generator = ToyGenerator()
            env = BinPack(generator, 40)
            key = jax.random.key(0)
            reset_state = env.generator(key)
            env.render(reset_state)
            solution = env.generator.generate_solution(key)
            env.render(solution)
            ```
        """
        solution = self._generate_solved_instance(key)
        return solution

    def _generate_solved_instance(self, key: chex.PRNGKey) -> State:
        """Generate the 20-ft instance with all items correctly packed."""
        container = make_container(self.container_dims)

        list_of_ems = [container] + (self.max_num_ems - 1) * [empty_ems()]
        ems = tree_transpose(list_of_ems)
        ems_mask = jnp.zeros(self.max_num_ems, bool)

        items = Item(
            x_len=jnp.array(
                [
                    2445,
                    3083,
                    1950,
                    3425,
                    3083,
                    2787,
                    3425,
                    2787,
                    2787,
                    3425,
                    3083,
                    2787,
                    1295,
                    2787,
                    3083,
                    3425,
                    3425,
                    837,
                    1150,
                    3425,
                ],
                jnp.int32,
            ),
            y_len=jnp.array(
                [
                    1306,
                    1429,
                    1301,
                    321,
                    1165,
                    2330,
                    291,
                    1504,
                    826,
                    466,
                    901,
                    1029,
                    1024,
                    2330,
                    1165,
                    466,
                    663,
                    1301,
                    1024,
                    589,
                ],
                jnp.int32,
            ),
            z_len=jnp.array(
                [
                    1022,
                    549,
                    700,
                    1022,
                    629,
                    200,
                    1022,
                    157,
                    157,
                    363,
                    549,
                    700,
                    1022,
                    121,
                    629,
                    659,
                    1022,
                    700,
                    1022,
                    1022,
                ],
                jnp.int32,
            ),
        )
        items_mask = jnp.ones(self.max_num_items, bool)

        sorted_ems_indexes = jnp.arange(0, self.max_num_ems, dtype=jnp.int32)

        items_location = Location(
            x=jnp.array(
                [
                    0,
                    0,
                    3083,
                    2445,
                    0,
                    3083,
                    2445,
                    3083,
                    3083,
                    2445,
                    0,
                    3083,
                    0,
                    3083,
                    0,
                    2445,
                    2445,
                    5033,
                    1295,
                    2445,
                ],
                jnp.int32,
            ),
            y=jnp.array(
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    910,
                    0,
                    1504,
                    1864,
                    1429,
                    1301,
                    1306,
                    0,
                    1165,
                    1864,
                    1201,
                    0,
                    1306,
                    321,
                ],
                jnp.int32,
            ),
            z=jnp.array(
                [
                    0,
                    1022,
                    1022,
                    0,
                    1571,
                    1722,
                    0,
                    2043,
                    2043,
                    0,
                    1022,
                    1022,
                    0,
                    1922,
                    1571,
                    363,
                    0,
                    1022,
                    0,
                    0,
                ],
                jnp.int32,
            ),
        )
        solution = State(
            container=container,
            ems=ems,
            ems_mask=ems_mask,
            items=items,
            items_mask=items_mask,
            items_placed=items_mask,
            items_location=items_location,
            action_mask=None,
            sorted_ems_indexes=sorted_ems_indexes,
            # For non value based optimisation set these to dummy values by default
            instance_max_item_value_magnitude=0.0,
            instance_total_value=0.0,
            key=jax.random.PRNGKey(0),
            nb_items=20,
        )

        return solution


class CSVGenerator(Generator):
    """`Generator` that parses a CSV file to do active search on a single instance. It
    always resets to the same instance defined by the CSV file. The generator can handle any
    container dimensions but assumes a 20-ft container by default.

    The CSV file is expected to have the following columns:
    - Item_Name
    - Length
    - Width
    - Height
    - Quantity

    Example of such a CSV file:
        Item_Name,Length,Width,Height,Quantity
        shape_1,1080,760,300,5
        shape_2,1100,430,250,3
    """

    def __init__(
        self,
        csv_path: str,
        max_num_ems: int,
        container_dims: Tuple[int, int, int] = TWENTY_FOOT_DIMS,
    ):
        """Instantiate a `CSVGenerator` that generates the same instance (active search)
        defined by a CSV file.

        Args:
            csv_path: path to the CSV file defining the instance to reset to.
            max_num_ems: maximum number of ems the environment will handle. This defines the shape
                of the EMS buffer that is kept in the environment state. The good number heavily
                depends on the number of items (given by the CSV file).
            container_dims: (length, width, height) tuple of integers corresponding to the
                dimensions of the container in millimeters. By default, assume a 20-ft container.
        """
        self.instance_from_csv = self._parse_csv_file(
            csv_path, max_num_ems, container_dims
        )
        max_num_items = self.instance_from_csv.items_mask.shape[0]
        super().__init__(max_num_items, max_num_ems, container_dims)

    def __call__(self, key: chex.PRNGKey) -> State:
        """Call method responsible for generating a new state.

        Args:
            key: key is not used as the instance is deterministically generated from CSV file.

        Returns:
            A `BinPack` state that corresponds to the instance defined by the CSV file.
        """
        del key
        return self.instance_from_csv

    def _parse_csv_file(
        self, csv_path: str, max_num_ems: int, container_dims: Tuple[int, int, int]
    ) -> State:
        """Create an instance by parsing a CSV file.

        Args:
            csv_path: path to the CSV file to parse that defines the instance to reset to.
            max_num_ems: maximum number of ems the environment will handle. This defines the shape
                of the EMS buffer that is kept in the environment state.
            container_dims: (length, width, height) tuple of integers corresponding to the
                dimensions of the container in millimeters.

        Returns:
            `BinPack` state that contains the instance defined in the CSV file.
        """
        container = make_container(container_dims)

        # Initialize the EMSs
        list_of_ems = [container] + (max_num_ems - 1) * [empty_ems()]
        ems = tree_transpose(list_of_ems)
        ems_mask = jnp.zeros(max_num_ems, bool).at[0].set(True)

        # Parse the CSV file to generate the items
        rows = self._read_csv(csv_path)
        list_of_items = self._generate_list_of_items(rows)
        items = tree_transpose(list_of_items)

        # Initialize items mask and location
        num_items = len(list_of_items)
        items_mask = jnp.ones(num_items, bool)
        items_placed = jnp.zeros(num_items, bool)
        items_location = Location(*tuple(jnp.zeros((3, num_items), jnp.int32)))

        sorted_ems_indexes = jnp.arange(0, max_num_ems, dtype=jnp.int32)
        reset_state = State(
            container=container,
            ems=ems,
            ems_mask=ems_mask,
            items=items,
            items_mask=items_mask,
            items_placed=items_placed,
            items_location=items_location,
            action_mask=None,
            sorted_ems_indexes=sorted_ems_indexes,
            # For non value based optimisation set these to dummy values by default
            instance_max_item_value_magnitude=0.0,
            instance_total_value=0.0,
            key=jax.random.PRNGKey(0),
            nb_items=num_items,
        )

        return reset_state

    def _read_csv(self, csv_path: str) -> List[Tuple[str, int, int, int, int]]:
        rows = []
        with open(csv_path, newline="") as csvfile:
            reader = csv.reader(csvfile)
            for row_index, row in enumerate(reader):
                if row_index == 0:
                    if len(row) != len(CSV_COLUMNS):
                        raise ValueError(
                            f"Got wrong number of columns, expected: {', '.join(CSV_COLUMNS)}"
                        )
                    elif row != CSV_COLUMNS:
                        raise ValueError("Columns in wrong order")
                else:
                    # Column order: Item_Name, Length, Width, Height, Quantity.
                    rows.append(
                        (
                            row[0],
                            int(row[1]),
                            int(row[2]),
                            int(row[3]),
                            int(row[4]),
                        )
                    )
        return rows

    def _generate_list_of_items(
        self, rows: List[Tuple[str, int, int, int, int]]
    ) -> List[Item]:
        """Generate the list of items from a Pandas DataFrame.

        Args:
            rows: List[tuple] describing the items for the corresponding instance.

        Returns:
            List of `Item` flattened so that identical items (quantity > 1) are copied according to
                their quantity.
        """
        list_of_items = []
        for (_, x_len, y_len, z_len, quantity) in rows:
            identical_items = quantity * [
                Item(
                    x_len=jnp.array(x_len, jnp.int32),
                    y_len=jnp.array(y_len, jnp.int32),
                    z_len=jnp.array(z_len, jnp.int32),
                )
            ]
            list_of_items.extend(identical_items)
        return list_of_items


def save_instance_to_csv(state: State, path: str) -> None:
    """Save an instance to a CSV file. The conversion to CSV will save item dimensions
    in millimeters.

    Args:
        state: `BinPack` state.
        path: path to save the CSV file.

    Returns:
        None

    Example:
        Item_Name,Length,Width,Height,Quantity
        shape_1,1080,760,300,5
        shape_2,1100,430,250,3
    """
    items = list(zip(state.items.x_len, state.items.y_len, state.items.z_len))
    items = [
        tuple(x.item() for x in item)
        for item, mask in zip(items, state.items_mask)
        if mask and all(x > 0 for x in item)
    ]
    grouped_items = list(collections.Counter(items).items())
    grouped_items.sort(key=operator.itemgetter(1), reverse=True)
    rows = [
        (f"shape_{i}", *item, count)
        for i, (item, count) in enumerate(grouped_items, start=1)
    ]
    with open(path, "w", newline="") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(CSV_COLUMNS)
        writer.writerows(rows)


class RandomGenerator(Generator):
    """Instance generator that generates random instances by splitting a container into different
    items in a random fashion. The generation works as follows. At each step, a space inside the
    container is chosen and split either into 2 items of random size or into more than 2 items of
    the same size, all becoming new spaces to potentially split. It starts with the whole container
    as unique space and then ends when enough items are created, i.e., when
    `num_items >= max_num_items - _split_num_same_items + 1`.

    Example:
        ```python
        generator = RandomGenerator(max_num_items=20, max_num_ems=80)
        env = BinPack(generator)
        key = jax.random.key(0)
        reset_state = generator(key)
        env.render(reset_state)
        solution = generator.generate_solution(key)
        env.render(solution)
        ```
    """

    def __init__(
        self,
        max_num_items: int,
        max_num_ems: int,
        split_eps: float = 0.3,
        prob_split_one_item: float = 0.7,
        split_num_same_items: int = 5,
        container_dims: Tuple[int, int, int] = TWENTY_FOOT_DIMS,
    ):
        """Instantiate a `RandomGenerator`.

        Args:
            max_num_items: maximum number of items the generator will ever generate when creating
                a new instance. This defines the shapes of arrays related to items in the
                environment state. The more items the more difficult the environment will be.
            max_num_ems: maximum number of ems the environment will handle. This defines the shape
                of the EMS buffer that is kept in the environment state. The good number heavily
                depends on the number of items (given by `max_num_items`).
            split_eps: fraction of edges of a space that cannot be chosen as a split point. This
                prevents from infinitely small items and biases the distribution towards
                reasonable-size items. Defaults to 0.3.
            prob_split_one_item: probability of splitting a space into 2 non-equal spaces.
                Otherwise, the split is done into multiple copies of the same divided space.
                Defaults to 0.7.
            split_num_same_items: if a space is split into multiple spaces (probability
                `1 - split_one_item_proba`), the number of spaces to split it into is chosen
                uniformly between 1 and `split_num_same_items`. Defaults to 5.
            container_dims: (length, width, height) tuple of integers corresponding to the
                dimensions of the container in millimeters. By default, assume a 20-ft container.
        """
        super().__init__(max_num_items, max_num_ems, container_dims)
        self._split_eps = split_eps
        self._prob_split_one_item = prob_split_one_item
        self._split_num_same_items = split_num_same_items

    def __call__(self, key: chex.PRNGKey) -> State:
        """Call method responsible for generating a new state.

        Args:
            key: jax random key for generating random splits.

        Returns:
            A `BinPack` state that corresponds to a random instance.
        """
        solution = self._generate_solved_instance(key)
        state = self._unpack_items(solution)

        return state

    def generate_solution(self, key: chex.PRNGKey) -> State:
        """Returns a state in which all items are placed to show a solution to the packing problem.
        The state corresponds to the end of an episode that was run with the optimal policy.

        Args:
            key: same jax random key used than when calling `__call__` to generate the same
                instance.

        Returns:
            A `BinPack` state whose items are all placed.

        Example:
            ```python
            generator = RandomGenerator()
            env = BinPack(generator)
            key = jax.random.key(0)
            reset_state = env.generator(key)
            env.render(reset_state)
            solution = env.generator.generate_solution(key)
            env.render(solution)
            ```
        """
        solution = self._generate_solved_instance(key)
        return solution

    def _generate_solved_instance(self, key: chex.PRNGKey) -> State:
        """Generate the random instance with all items correctly packed."""
        key, split_key = jax.random.split(key)
        container = make_container(self.container_dims)

        list_of_ems = [container] + (self.max_num_ems - 1) * [empty_ems()]
        ems = tree_transpose(list_of_ems)
        ems_mask = jnp.zeros(self.max_num_ems, bool)

        items_spaces, items_mask = self._split_container_into_items_spaces(
            container, split_key
        )
        nb_items = jnp.sum(items_mask)
        items = item_from_space(items_spaces)
        sorted_ems_indexes = jnp.arange(0, self.max_num_ems, dtype=jnp.int32)

        all_item_locations = location_from_space(items_spaces)
        solution = State(
            container=container,
            ems=ems,
            ems_mask=ems_mask,
            items=items,
            items_mask=items_mask,
            items_placed=items_mask,
            items_location=all_item_locations,
            action_mask=None,
            sorted_ems_indexes=sorted_ems_indexes,
            # For non value based optimisation set these to dummy values by default
            instance_max_item_value_magnitude=0.0,
            instance_total_value=0.0,
            key=key,
            nb_items=nb_items,
        )
        return solution

    def _split_container_into_items_spaces(
        self,
        container: Container,
        key: chex.PRNGKey,
        input_max_items_generated: Optional[int] = None,
    ) -> Tuple[Space, chex.Array]:
        """Split one space (the container) into several sub-spaces that will be identified as
        items.

        The output items_spaces and items_mask array will be self.max_num_items by default but can
        be set to a custom value that is different from this (useful for
        RandomValueProblemGenerator).
        """
        max_items_generated = cast(int, input_max_items_generated) or self.max_num_items

        chex.assert_rank(list(container.__dict__.values()), 0)

        def cond_fun(val: Tuple[Space, chex.Array, chex.PRNGKey]) -> jnp.bool_:
            _, items_mask, _ = val
            num_placed_items = jnp.sum(items_mask)
            return (
                num_placed_items < max_items_generated - self._split_num_same_items + 1
            )

        def body_fun(
            val: Tuple[Space, chex.Array, chex.PRNGKey]
        ) -> Tuple[Space, chex.Array, chex.PRNGKey]:
            items_spaces, items_mask, key = val
            key, subkey = jax.random.split(key)
            items_spaces, items_mask = self._split_space_into_sub_spaces(
                items_spaces, items_mask, subkey
            )
            next_val = items_spaces, items_mask, key
            return next_val

        items_spaces = Space(
            **jax.tree_util.tree_map(
                lambda x: x * jnp.ones(max_items_generated, jnp.int32), container
            ).__dict__
        )
        items_mask = jnp.zeros(max_items_generated, bool).at[0].set(True)
        init_val = (items_spaces, items_mask, key)
        (items_spaces, items_mask, _) = jax.lax.while_loop(cond_fun, body_fun, init_val)

        return items_spaces, items_mask

    def _split_space_into_sub_spaces(
        self, items_spaces: Space, items_mask: chex.Array, key: chex.PRNGKey
    ) -> Tuple[Space, chex.Array]:
        """Sample an axis along which to split an item."""
        chex.assert_rank([items_mask, *list(items_spaces.__dict__.values())], 1)
        axis_key, split_key = jax.random.split(key)

        # Choose a random axis to split along.
        axis = jax.random.randint(
            key=axis_key,
            shape=(),
            minval=0,
            maxval=3,
        )

        # Call `_split_along_axis` on the sampled axis: 0 -> x, 1 -> y, 2 -> z.
        items_spaces, items_mask = jax.lax.switch(
            axis,
            [
                functools.partial(self._split_along_axis, "x"),
                functools.partial(self._split_along_axis, "y"),
                functools.partial(self._split_along_axis, "z"),
            ],
            items_spaces,
            items_mask,
            split_key,
        )

        # Remove possibly empty items (a dimension may be split to 0).
        items_mask &= ~items_spaces.is_empty()

        return items_spaces, items_mask

    def _split_along_axis(
        self, axis: str, items_spaces: Space, items_mask: chex.Array, key: chex.PRNGKey
    ) -> Tuple[Space, chex.Array]:
        """Given an axis, sample a space to split proportionally to its length on that axis.
        Then, either split the space in two different spaces or split it into a several
        identical sub-spaces.
        """
        current_items = item_from_space(items_spaces)
        item_length = getattr(current_items, f"{axis}_len")
        item_key, split_key, mode_key = jax.random.split(key, 3)
        item_id = jax.random.choice(
            item_key,
            jnp.arange(0, len(items_mask)),
            (),
            p=jnp.where(items_mask, item_length, 0),
        )
        item_space = tree_slice(items_spaces, item_id)
        item_axis_1 = item_space.get_axis_value(axis, 1)
        item_axis_2 = item_space.get_axis_value(axis, 2)
        axis_len = item_axis_2 - item_axis_1

        items_spaces, items_mask = jax.lax.cond(
            jax.random.uniform(mode_key) < self._prob_split_one_item,
            functools.partial(
                self._split_item_once, item_space, axis, axis_len, item_id
            ),
            functools.partial(
                self._split_item_multiple_times, item_space, axis, axis_len, item_id
            ),
            items_spaces,
            items_mask,
            split_key,
        )
        return items_spaces, items_mask

    def _split_item_once(
        self,
        item_space: Space,
        axis: str,
        axis_len: int,
        item_id: int,
        items_spaces: Space,
        items_mask: chex.Array,
        split_key: chex.PRNGKey,
    ) -> Tuple[Space, chex.Array]:
        """Split an item into two sub-spaces. The split position is sampled uniformly on the
        space axis length with paddings equal to `_split_eps`% on each side of the space.
        """
        axis_min, axis_max = (
            item_space.get_axis_value(axis, 1)
            + jnp.array(self._split_eps * axis_len, jnp.int32),
            item_space.get_axis_value(axis, 2)
            - jnp.array(self._split_eps * axis_len, jnp.int32),
        )
        axis_split = jax.random.randint(split_key, (), axis_min, axis_max, jnp.int32)
        free_index = jnp.argmin(items_mask)
        items_spaces = jax.tree_util.tree_map(
            lambda coord: coord.at[free_index].set(coord[item_id]), items_spaces
        )
        new_axis_2 = items_spaces.get_axis_value(axis, 2).at[item_id].set(axis_split)
        items_spaces.set_axis_value(axis, 2, new_axis_2)
        new_axis_1 = items_spaces.get_axis_value(axis, 1).at[free_index].set(axis_split)
        items_spaces.set_axis_value(axis, 1, new_axis_1)
        items_mask = items_mask.at[free_index].set(True)
        return items_spaces, items_mask

    def _split_item_multiple_times(
        self,
        item_space: Space,
        axis: str,
        axis_len: int,
        item_id: int,
        items_spaces: Space,
        items_mask: chex.Array,
        split_key: chex.PRNGKey,
    ) -> Tuple[Space, chex.Array]:
        """Split an item into several identical sub-spaces. The number of these spaces is
        uniformly sampled between 0 and `_split_num_same_items`.
        """
        initial_item_axis_1 = item_space.get_axis_value(axis, 1)
        num_split = jax.random.randint(split_key, (), 1, self._split_num_same_items + 1)

        # Shortens first item before the others as its mask is already True.
        new_items_axis_2 = (
            items_spaces.get_axis_value(axis, 2)
            .at[item_id]
            .set(initial_item_axis_1 + jnp.array(axis_len / num_split, jnp.int32))
        )
        items_spaces.set_axis_value(axis, 2, new_items_axis_2)

        def body_fn(
            i: int, carry: Tuple[Space, chex.Array]
        ) -> Tuple[Space, chex.Array]:
            items_spaces, items_mask = carry
            free_index = jnp.argmin(items_mask)
            items_spaces = jax.tree_util.tree_map(
                lambda coord: coord.at[free_index].set(coord[item_id]),
                items_spaces,
            )
            item_axis_1 = initial_item_axis_1 + jnp.array(
                i * axis_len / num_split, jnp.int32
            )
            item_axis_2 = initial_item_axis_1 + jnp.array(
                (i + 1) * axis_len / num_split, jnp.int32
            )
            new_items_axis_1 = (
                items_spaces.get_axis_value(axis, 1).at[free_index].set(item_axis_1)
            )
            items_spaces.set_axis_value(axis, 1, new_items_axis_1)
            new_items_axis_2 = (
                items_spaces.get_axis_value(axis, 2).at[free_index].set(item_axis_2)
            )
            items_spaces.set_axis_value(axis, 2, new_items_axis_2)
            items_mask = items_mask.at[free_index].set(True)
            return items_spaces, items_mask

        # Loop over identical items to create from splitting the original item into several ones
        items_spaces, items_mask = jax.lax.fori_loop(
            1,
            num_split,
            body_fn,
            (items_spaces, items_mask),
        )

        return items_spaces, items_mask


class RandomValueProblemGenerator(RandomGenerator):
    """Instance generator that generates random instances by splitting a container into different
    items in a random fashion. The generation works as follows. Firstly random items are generated
    as for the RandomGenerator but the number of items generated is no more than half of
    max_num_items. These items are then duplicated (having enough items to fit 2 containers
    perfectly). ValuedItems are created by sampling values from a normal distribution of mean and
    standard deviation defined at initiation. The first set of items are set to have a value equal
    to their counterparts in the duplicated items plus the total value of the duplicated items.
    This is to avoid the agent depending only on volume features for packing a container well (to do
    so it also needs to distinguish between 2 items that have the same shape but different values)
    but also to ensure that we can guarantee the optimal solution is packing the first set of items.

    Example:
        ```python
        generator = RandomGenerator(max_num_items=20, max_num_ems=80)
        env = BinPack(generator)
        key = jax.random.key(0)
        reset_state = generator(key)
        env.render(reset_state)
        solution = generator.generate_solution(key)
        env.render(solution)
        ```
    """

    def __init__(
        self,
        max_num_items: int,
        max_num_ems: int,
        split_eps: float = 0.3,
        prob_split_one_item: float = 0.7,
        split_num_same_items: int = 5,
        container_dims: Tuple[int, int, int] = TWENTY_FOOT_DIMS,
        mean_value: float = 1,
        standard_deviation_value: float = 0.5,
    ):
        """Instantiate a `RandomValueProblemGenerator`.

        Args:
            max_num_items: maximum number of items the generator will ever generate when creating
                a new instance. This defines the shapes of arrays related to items in the
                environment state. The more items the more difficult the environment will be.
            max_num_ems: maximum number of ems the environment will handle. This defines the shape
                of the EMS buffer that is kept in the environment state. The good number heavily
                depends on the number of items (given by `max_num_items`).
            split_eps: fraction of edges of a space that cannot be chosen as a split point. This
                prevents from infinitely small items and biases the distribution towards
                reasonable-size items. Defaults to 0.3.
            prob_split_one_item: probability of splitting a space into 2 non-equal spaces.
                Otherwise, the split is done into multiple copies of the same divided space.
                Defaults to 0.7.
            split_num_same_items: if a space is split into multiple spaces (probability
                `1 - split_one_item_proba`), the number of spaces to split it into is chosen
                uniformly between 1 and `split_num_same_items`. Defaults to 5.
            container_dims: (length, width, height) tuple of integers corresponding to the
                dimensions of the container in millimeters. By default, assume a 20-ft container.
            mean_value: The mean value of the normal distribution from which the item values will be
                sampled.
            standard_deviation_value: The standard divation of the normal distribution from whic
                the item values will be sampled.
        """
        super().__init__(
            max_num_items,
            max_num_ems,
            split_eps,
            prob_split_one_item,
            split_num_same_items,
            container_dims,
        )
        self.mean_value = mean_value
        self.standard_deviation_value = standard_deviation_value

    def _generate_solved_instance(self, key: chex.PRNGKey) -> State:
        """Generate the random instance with half of all items correctly packed (the higher value
        half). The other half of the generated items remain unpacked.

        The first half of items are generated by splitting the container in the same way as the
        inherited RandomGenerator class, but with less than half the max_num_items. Values are
        randomly generated, doubled and assigned to these items. These items are
        duplicated and assigned values that are half the value of the original items. This means
        that the optimal solution is to fill one container perfectly with the higher valued items.
        This method may lead to fewer than max_num_items being generated in total, but the items
        tree will be of size max_num_items and the indexes that don't correspond to the items of the
        instance are masked out with the state's items_mask.
        """
        key, split_key = jax.random.split(key)
        container = make_container(self.container_dims)

        list_of_ems = [container] + (self.max_num_ems - 1) * [empty_ems()]
        ems = tree_transpose(list_of_ems)
        ems_mask = jnp.zeros(self.max_num_ems, bool)

        # Create less than half of max_num_items item spaces by splitting up a container. This
        # will lead to nb_items_in_one_container items that fit perfectly into a single container.
        nb_items_in_one_container = math.floor(0.5 * self.max_num_items)
        # This will generate items_spaces and item_mask of size nb_items_in_one_container.
        items_spaces, items_mask = self._split_container_into_items_spaces(
            container, split_key, nb_items_in_one_container
        )
        # Randomly generate values that will then be increased by a value of
        # total_value_of_generated_values to generate a "perfect instance" with a known optimal
        # solution.
        key, split_key = jax.random.split(key)
        item_values = self.mean_value + (
            self.standard_deviation_value
            * jax.random.normal(split_key, (len(items_mask),), jnp.float32)
        )
        total_value_of_generated_values = sum(item_values)
        # Assign values to the items that are packed in the optimal solution. To ensure an optimal
        # solution, the total value of the duplicated item values are added to the original
        # generated item values.
        optimal_items = valued_item_from_space_and_max_value(
            items_spaces, item_values + total_value_of_generated_values
        )
        # Duplicate the above items and assign values to them that are half their counterparts
        # above.
        extra_items = valued_item_from_space_and_max_value(items_spaces, item_values)

        # If self.max_num_items is an odd number, the concatenation of items and extra_items would
        # result in a tree size of < self.max_num_items. In this case, we add padding.
        padding_of_int_ones = jnp.ones(
            self.max_num_items - 2 * len(items_mask), jnp.int32
        )
        padding_of_float_ones = jnp.ones(
            self.max_num_items - 2 * len(items_mask), jnp.float32
        )
        padding_of_bool_zeros = jnp.zeros(
            self.max_num_items - 2 * len(items_mask), bool
        )
        padding_items = ValuedItem(
            padding_of_int_ones * container.x2,
            padding_of_int_ones * container.y2,
            padding_of_int_ones * container.z2,
            padding_of_float_ones,
        )

        # Create the solution state by creating trees of size self.max_num_items for items,
        # items_placable_at_beginning_mask and items_placed_mask.
        items = jax.tree_map(
            lambda x, y, z: jnp.concatenate((x, y, z)),
            optimal_items,
            extra_items,
            padding_items,
        )
        items_placable_at_beginning_mask = jnp.concatenate(
            (items_mask, items_mask, padding_of_bool_zeros)
        )
        zeros_of_size_nb_extra_items = jnp.zeros(items_mask.shape, bool)
        items_placed_mask = jnp.concatenate(
            (items_mask, zeros_of_size_nb_extra_items, padding_of_bool_zeros)
        )

        sorted_ems_indexes = jnp.arange(0, self.max_num_ems, dtype=jnp.int32)

        # Create locations for placed, unplaced and padded items.
        placed_items_locations = location_from_space(items_spaces)
        remaining_items_locations = Location(
            x=jnp.zeros(self.max_num_items - len(items_mask), jnp.int32),
            y=jnp.zeros(self.max_num_items - len(items_mask), jnp.int32),
            z=jnp.zeros(self.max_num_items - len(items_mask), jnp.int32),
        )
        all_item_locations = jax.tree_map(
            lambda x, y: jnp.concatenate((x, y)),
            placed_items_locations,
            remaining_items_locations,
        )

        instance_total_value = jnp.sum(items.value * items_placable_at_beginning_mask)
        instance_max_item_value_magnitude = jnp.max(
            abs(items.value * items_placable_at_beginning_mask)
        )

        solution = State(
            container=container,
            ems=ems,
            ems_mask=ems_mask,
            items=items,
            nb_items=len(items.x_len),
            items_mask=items_placable_at_beginning_mask,
            items_placed=items_placed_mask,
            items_location=all_item_locations,
            action_mask=None,
            sorted_ems_indexes=sorted_ems_indexes,
            instance_max_item_value_magnitude=instance_max_item_value_magnitude,
            instance_total_value=instance_total_value,
            key=key,
        )
        return solution


class ValueProblemCSVGenerator(CSVGenerator):
    """`Generator` that parses a CSV file to do active search on a single instance. It
    always resets to the same instance defined by the CSV file. The generator can handle any
    container dimensions but assumes a 20-ft container by default.

    The CSV file is expected to have the following columns:
    - Item_Name
    - Length
    - Width
    - Height
    - Quantity
    - Value

    Example with value:
        Item_Name,Length,Width,Height,Quantity,Value
        shape_1,1080,760,300,5,4.5
        shape_2,1100,430,250,3,3.4
    """

    def __init__(
        self,
        csv_path: str,
        max_num_ems: int,
        container_dims: Tuple[int, int, int] = TWENTY_FOOT_DIMS,
    ):
        """Instantiate a `CSVGenerator` that generates the same instance (active search)
        defined by a CSV file.

        Args:
            csv_path: path to the CSV file defining the instance to reset to.
            max_num_ems: maximum number of ems the environment will handle. This defines the shape
                of the EMS buffer that is kept in the environment state. The good number heavily
                depends on the number of items (given by the CSV file).
            container_dims: (length, width, height) tuple of integers corresponding to the
                dimensions of the container in millimeters. By default, assume a 20-ft container.
        """
        super().__init__(csv_path, max_num_ems, container_dims)

    def _parse_csv_file(
        self, csv_path: str, max_num_ems: int, container_dims: Tuple[int, int, int]
    ) -> State:
        """Create an instance by parsing a CSV file.

        Args:
            csv_path: path to the CSV file to parse that defines the instance to reset to.
            max_num_ems: maximum number of ems the environment will handle. This defines the shape
                of the EMS buffer that is kept in the environment state.
            container_dims: (length, width, height) tuple of integers corresponding to the
                dimensions of the container in millimeters.

        Returns:
            `BinPack` state that contains the instance defined in the CSV file.
        """
        container = make_container(container_dims)

        # Initialize the EMSs
        list_of_ems = [container] + (max_num_ems - 1) * [empty_ems()]
        ems = tree_transpose(list_of_ems)
        ems_mask = jnp.zeros(max_num_ems, bool).at[0].set(True)

        # Parse the CSV file to generate the items
        rows = self._read_valued_csv(csv_path)
        list_of_items = self._generate_list_of_valued_items(rows)
        items = tree_transpose(list_of_items)

        # Initialize items mask and location
        num_items = len(list_of_items)
        items_mask = jnp.ones(num_items, bool)
        items_placed = jnp.zeros(num_items, bool)
        items_location = Location(*tuple(jnp.zeros((3, num_items), jnp.int32)))

        sorted_ems_indexes = jnp.arange(0, max_num_ems, dtype=jnp.int32)

        instance_total_value = jnp.sum(items.value * items_mask)
        instance_max_item_value_magnitude = jnp.max(abs(items.value * items_mask))

        reset_state = State(
            container=container,
            ems=ems,
            ems_mask=ems_mask,
            items=items,
            nb_items=len(items.x_len),
            items_mask=items_mask,
            items_placed=items_placed,
            items_location=items_location,
            action_mask=None,
            sorted_ems_indexes=sorted_ems_indexes,
            instance_max_item_value_magnitude=instance_max_item_value_magnitude,
            instance_total_value=instance_total_value,
            key=jax.random.PRNGKey(0),
        )

        return reset_state

    def _read_valued_csv(
        self, csv_path: str
    ) -> List[Tuple[str, int, int, int, int, float]]:
        rows = []
        with open(csv_path, newline="") as csvfile:
            reader = csv.reader(csvfile)
            for row_index, row in enumerate(reader):
                if row_index == 0:
                    if len(row) != len(CSV_VALUE_PROBLEM_COLUMNS):
                        raise ValueError(
                            "Got wrong number of columns, expected: "
                            f"{', '.join(CSV_VALUE_PROBLEM_COLUMNS)}"
                        )
                    elif row != CSV_VALUE_PROBLEM_COLUMNS:
                        raise ValueError("Columns in wrong order")
                else:
                    # Column order: Item_Name, Length, Width, Height, Quantity, Value.
                    rows.append(
                        (
                            row[0],
                            int(row[1]),
                            int(row[2]),
                            int(row[3]),
                            int(row[4]),
                            float(row[5]),
                        )
                    )
        return rows

    def _generate_list_of_valued_items(
        self, rows: List[Tuple[str, int, int, int, int, float]]
    ) -> List[ValuedItem]:
        """Generate the list of items from a Pandas DataFrame.

        Args:
            rows: List[tuple] describing the items for the corresponding instance.

        Returns:
            List of `ValuedItem` flattened so that identical items (quantity > 1) are copied
            according to their quantity.
        """
        list_of_items = []
        for (_, x_len, y_len, z_len, quantity, value) in rows:
            identical_items = quantity * [
                ValuedItem(
                    x_len=jnp.array(x_len, jnp.int32),
                    y_len=jnp.array(y_len, jnp.int32),
                    z_len=jnp.array(z_len, jnp.int32),
                    value=jnp.array(value, jnp.float32),
                )
            ]
            list_of_items.extend(identical_items)
        return list_of_items


VALUE_BASED_GENERATORS = (
    RandomValueProblemGenerator,
    ValueProblemCSVGenerator,
)


class ConstrainedToyGenerator(ToyGenerator):
    def __init__(self) -> None:
        super().__init__()

    def _generate_solved_instance(self, key: chex.PRNGKey) -> State:
        solution = super()._generate_solved_instance(key)
        x_len, y_len, z_len = (
            solution.items.x_len,
            solution.items.y_len,
            solution.items.z_len,
        )
        solution.items = Item(
            x_len=jnp.array([x_len, x_len, y_len, y_len, z_len, z_len]),
            y_len=jnp.array([y_len, z_len, x_len, z_len, y_len, x_len]),
            z_len=jnp.array([z_len, y_len, z_len, x_len, x_len, y_len]),
        )

        solution.items_mask = jnp.array(
            [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                # Since only the items
                # 2, 12, 17 and 18 can be placed with their length along any of the container axes,
                # we mask these orientations of the other items.
                [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0],
                [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0],
                [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0],
                [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0],
            ]
        )
        return solution

    def _unpack_items(self, state: State) -> State:
        state = super()._unpack_items(state)
        state.items_placed = jnp.zeros((6, self.max_num_items), bool)
        return state


class ConstrainedRandomGenerator(RandomGenerator):
    def __init__(
        self,
        max_num_items: int,
        max_num_ems: int,
        split_eps: float = 0.3,
        prob_split_one_item: float = 0.7,
        split_num_same_items: int = 5,
        container_dims: Tuple[int, int, int] = TWENTY_FOOT_DIMS,
    ):
        super().__init__(
            max_num_items,
            max_num_ems,
            split_eps,
            prob_split_one_item,
            split_num_same_items,
            container_dims,
        )

    def _generate_solved_instance(self, key: chex.PRNGKey) -> State:
        solved_instance = super()._generate_solved_instance(key)
        solved_instance.items = rotated_items_from_space(
            space_from_item_and_location(
                solved_instance.items, solved_instance.items_location
            )
        )
        solved_instance.items_mask = jnp.broadcast_to(
            solved_instance.items_mask, (6, solved_instance.items_mask.shape[0])
        )
        return solved_instance

    def _unpack_items(self, state: State) -> State:
        state = super()._unpack_items(state)
        state.items_placed = jnp.zeros((6, self.max_num_items), bool)
        return state


class FullSupportRandomGenerator(RandomGenerator):
    def __init__(
        self,
        max_num_items: int,
        max_num_ems: int,
        split_eps: float = 0.3,
        prob_split_one_item: float = 0.7,
        split_num_same_items: int = 5,
        container_dims: Tuple[int, int, int] = TWENTY_FOOT_DIMS,
    ):
        super().__init__(
            max_num_items,
            max_num_ems,
            split_eps,
            prob_split_one_item,
            split_num_same_items,
            container_dims,
        )

    def _split_space_into_sub_spaces(
        self, items_spaces: Space, items_mask: chex.Array, key: chex.PRNGKey
    ) -> Tuple[Space, chex.Array]:
        """Sample an axis along which to split an item."""
        chex.assert_rank([items_mask, *list(items_spaces.__dict__.values())], 1)
        axis_key, split_key = jax.random.split(key)

        # Choose a random axis to split along.
        axis = jax.random.randint(
            key=axis_key,
            shape=(),
            minval=0,
            maxval=2,
        )

        # Call `_split_along_axis` on the sampled axis: 0 -> x, 1 -> y, 2 -> z.
        items_spaces, items_mask = jax.lax.switch(
            axis,
            [
                functools.partial(self._split_along_axis, "x"),
                functools.partial(self._split_along_axis, "y"),
            ],
            items_spaces,
            items_mask,
            split_key,
        )

        # Remove possibly empty items (a dimension may be split to 0).
        items_mask &= ~items_spaces.is_empty()

        return items_spaces, items_mask
